"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/dataService.ts":
/*!*********************************!*\
  !*** ./services/dataService.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataService: () => (/* binding */ dataService),\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _utils_haversine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/haversine */ \"(app-pages-browser)/./utils/haversine.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n// --- CONFIG ---\nconst SUPABASE_URL = \"https://rhgbghiznkqrvdbqufmq.supabase.co\" || 0;\nconst SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || 'mock-key';\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(SUPABASE_URL, SUPABASE_KEY);\n// --- MOCK DATA STORE (LocalStorage persistence for demo) ---\nconst STORAGE_KEY = 'linkme_mock_db_v5';\n// Pre-seeded rich data for the \"Demo User\" ('me')\nconst SEEDED_DB = {\n    users: [\n        {\n            id: 'me',\n            email: 'demo@linkme.com',\n            name: 'Demo User',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=me'\n        },\n        {\n            id: '1',\n            email: 'aman@example.com',\n            name: 'Aman Roy',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=aman'\n        },\n        {\n            id: '2',\n            email: 'maya@example.com',\n            name: 'Maya Sen',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=maya'\n        },\n        {\n            id: '3',\n            email: 'elara@tech.com',\n            name: 'Elara Vance',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=elara'\n        }\n    ],\n    profiles: [\n        {\n            id: 'p_me_pro',\n            user_id: 'me',\n            profile_type: 'professional',\n            headline: 'Senior Product Designer',\n            bio: 'Obsessed with Swiss design and functional minimalism.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Studio Alpha',\n                    role: 'Lead Designer',\n                    from: '2021',\n                    to: 'Present'\n                },\n                {\n                    company: 'Freelance',\n                    role: 'UI/UX Consultant',\n                    from: '2019',\n                    to: '2021'\n                }\n            ],\n            education: [\n                {\n                    institution: 'Parsons',\n                    degree: 'BFA Design',\n                    year: '2018'\n                }\n            ],\n            skills: [\n                'Figma',\n                'React',\n                'Design Systems',\n                'Prototyping'\n            ],\n            open_to_work: true,\n            linkedin_url: 'linkedin.com/in/demo',\n            hobbies: [],\n            prompts: []\n        },\n        {\n            id: 'p_me_pers',\n            user_id: 'me',\n            profile_type: 'personal',\n            headline: 'Coffee & Marathons',\n            bio: 'Training for the NYC marathon. Always looking for new espresso spots.',\n            visibility: 'nearby',\n            experience: [],\n            education: [],\n            hobbies: [\n                'Running',\n                'Espresso',\n                'Architecture',\n                'Vinyl'\n            ],\n            prompts: [\n                {\n                    question: 'A perfect Sunday is...',\n                    answer: 'Running 10k then finding the perfect bagel.'\n                },\n                {\n                    question: 'I geek out on...',\n                    answer: 'Mid-century furniture.'\n                }\n            ],\n            relationship_goal: 'friends',\n            instagram_handle: '@demo_runs'\n        },\n        {\n            id: 'p1',\n            user_id: '1',\n            profile_type: 'professional',\n            headline: 'Product Manager @ Beacon Labs',\n            bio: 'Building tools for the future of work.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Beacon Labs',\n                    role: 'PM',\n                    from: '2021',\n                    to: 'Present'\n                }\n            ],\n            education: [],\n            skills: [\n                'Product Strategy',\n                'Agile',\n                'Jira'\n            ],\n            linkedin_url: 'linkedin.com/aman',\n            open_to_work: false,\n            hobbies: [],\n            prompts: []\n        },\n        {\n            id: 'p2',\n            user_id: '2',\n            profile_type: 'personal',\n            headline: 'Hiking & Photography',\n            bio: 'Looking for hiking buddies for upstate trails.',\n            visibility: 'nearby',\n            experience: [],\n            education: [],\n            instagram_handle: '@maya_hikes',\n            hobbies: [\n                'Hiking',\n                'Photography',\n                'Nature'\n            ],\n            relationship_goal: 'networking',\n            prompts: [\n                {\n                    question: 'My secret talent is...',\n                    answer: 'Finding the best sunset spots.'\n                }\n            ]\n        },\n        {\n            id: 'p3',\n            user_id: '3',\n            profile_type: 'professional',\n            headline: 'UX Researcher',\n            bio: 'Specializing in proximity interactions.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Google',\n                    role: 'Researcher',\n                    from: '2019',\n                    to: '2023'\n                }\n            ],\n            education: [],\n            skills: [\n                'Figma',\n                'User Testing'\n            ],\n            open_to_work: true,\n            hobbies: [],\n            prompts: []\n        }\n    ],\n    locations: [\n        {\n            id: 'l1',\n            user_id: '1',\n            latitude: 40.7160,\n            longitude: -74.0090,\n            updated_at: new Date().toISOString()\n        },\n        {\n            id: 'l2',\n            user_id: '2',\n            latitude: 40.7110,\n            longitude: -74.0020,\n            updated_at: new Date().toISOString()\n        },\n        {\n            id: 'l3',\n            user_id: '3',\n            latitude: 40.7140,\n            longitude: -74.0060,\n            updated_at: new Date().toISOString()\n        }\n    ],\n    connections: [],\n    messages: []\n};\nconst getMockDB = ()=>{\n    if (false) {}\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (!stored) {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(SEEDED_DB));\n        return SEEDED_DB;\n    }\n    return JSON.parse(stored);\n};\nconst updateMockDB = (newData)=>{\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(newData));\n};\n// --- SERVICE METHODS ---\nconst dataService = {\n    // Fetch users nearby from Supabase API\n    async fetchNearby (lat, lng, radius, userId) {\n        try {\n            // Try to fetch from Supabase API first\n            const params = new URLSearchParams({\n                lat: lat.toString(),\n                lng: lng.toString(),\n                radius: radius.toString()\n            });\n            if (userId) {\n                params.append('userId', userId);\n            }\n            const response = await fetch(\"/api/fetch-nearby?\".concat(params.toString()));\n            if (response.ok) {\n                const result = await response.json();\n                return result.data || [];\n            } else {\n                // If API fails, fall back to mock data for demo\n                console.warn('API fetch failed, falling back to mock data');\n                return this.fetchNearbyMock(lat, lng, radius);\n            }\n        } catch (error) {\n            console.error('Error fetching nearby users:', error);\n            // Fall back to mock data for demo\n            return this.fetchNearbyMock(lat, lng, radius);\n        }\n    },\n    // Fallback mock implementation\n    async fetchNearbyMock (lat, lng, radius) {\n        const db = getMockDB();\n        const nearby = [];\n        db.locations.forEach((loc)=>{\n            // Use Haversine to calculate distance from the PASSED lat/lng (User's location)\n            const dist = (0,_utils_haversine__WEBPACK_IMPORTED_MODULE_0__.getDistanceFromLatLonInMeters)(lat, lng, loc.latitude, loc.longitude);\n            if (dist <= radius) {\n                const user = db.users.find((u)=>u.id === loc.user_id);\n                const profile = db.profiles.find((p)=>p.user_id === loc.user_id && p.visibility !== 'private');\n                if (user && profile) {\n                    nearby.push({\n                        ...user,\n                        profile,\n                        location: loc,\n                        distance: dist\n                    });\n                }\n            }\n        });\n        // Simulate network delay\n        return new Promise((resolve)=>setTimeout(()=>resolve(nearby), 600));\n    },\n    // Get my profile\n    async getMyProfile (userId, type) {\n        try {\n            // Try to fetch from Supabase API first\n            const response = await fetch(\"/api/get-profile?userId=\".concat(userId, \"&profileType=\").concat(type));\n            if (response.ok) {\n                const result = await response.json();\n                if (result.data) {\n                    return result.data;\n                }\n            }\n            // If not found, create default profile in Supabase\n            const newProfile = {\n                id: \"p_\".concat(userId, \"_\").concat(type),\n                user_id: userId,\n                profile_type: type,\n                headline: type === 'professional' ? 'New Professional' : 'New User',\n                bio: '',\n                visibility: 'nearby',\n                experience: [],\n                education: [],\n                skills: [],\n                hobbies: [],\n                prompts: [],\n                open_to_work: false\n            };\n            // Save to Supabase\n            await fetch('/api/update-profile', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(newProfile)\n            });\n            return newProfile;\n        } catch (error) {\n            console.error('Error fetching profile:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const p = db.profiles.find((p)=>p.user_id === userId && p.profile_type === type);\n            if (!p) {\n                const newProfile = {\n                    id: \"p_\".concat(userId, \"_\").concat(type),\n                    user_id: userId,\n                    profile_type: type,\n                    headline: type === 'professional' ? 'New Professional' : 'New User',\n                    bio: '',\n                    visibility: 'nearby',\n                    experience: [],\n                    education: [],\n                    skills: [],\n                    hobbies: [],\n                    prompts: [],\n                    open_to_work: false\n                };\n                db.profiles.push(newProfile);\n                updateMockDB(db);\n                return newProfile;\n            }\n            return p;\n        }\n    },\n    // Update profile\n    async updateProfile (profile) {\n        try {\n            // Save to Supabase API\n            const response = await fetch('/api/update-profile', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(profile)\n            });\n            if (!response.ok) {\n                console.error('Failed to update profile in Supabase');\n                // Fallback to mock data\n                const db = getMockDB();\n                const idx = db.profiles.findIndex((p)=>p.id === profile.id);\n                if (idx !== -1) {\n                    db.profiles[idx] = profile;\n                } else {\n                    db.profiles.push(profile);\n                }\n                updateMockDB(db);\n            }\n        } catch (error) {\n            console.error('Error updating profile:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const idx = db.profiles.findIndex((p)=>p.id === profile.id);\n            if (idx !== -1) {\n                db.profiles[idx] = profile;\n            } else {\n                db.profiles.push(profile);\n            }\n            updateMockDB(db);\n        }\n    },\n    // Connections\n    async getConnections (userId) {\n        const db = getMockDB();\n        const connections = db.connections.filter((c)=>c.from_user === userId || c.to_user === userId);\n        // Hydrate with peer info\n        const hydrated = connections.map((c)=>{\n            const peerId = c.from_user === userId ? c.to_user : c.from_user;\n            const peer = db.users.find((u)=>u.id === peerId) || {\n                id: peerId,\n                name: 'Unknown',\n                email: ''\n            };\n            const peerProfile = db.profiles.find((p)=>p.user_id === peerId && p.profile_type === c.profile_type);\n            return {\n                ...c,\n                peer,\n                peer_profile: peerProfile\n            };\n        });\n        return Promise.resolve(hydrated);\n    },\n    async sendConnectionRequest (conn) {\n        try {\n            // Save to Supabase API\n            const response = await fetch('/api/send-connection', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    ...conn,\n                    id: conn.id || crypto.randomUUID(),\n                    status: 'pending',\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                })\n            });\n            if (!response.ok) {\n                console.error('Failed to save connection to Supabase');\n                // Fallback to mock data\n                const db = getMockDB();\n                const newConn = {\n                    ...conn,\n                    id: crypto.randomUUID(),\n                    status: 'pending',\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                db.connections.push(newConn);\n                updateMockDB(db);\n            }\n        } catch (error) {\n            console.error('Error sending connection request:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const newConn = {\n                ...conn,\n                id: crypto.randomUUID(),\n                status: 'pending',\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            db.connections.push(newConn);\n            updateMockDB(db);\n        }\n    },\n    async updateConnectionStatus (connId, status) {\n        const db = getMockDB();\n        const idx = db.connections.findIndex((c)=>c.id === connId);\n        if (idx !== -1) {\n            db.connections[idx].status = status;\n            updateMockDB(db);\n        }\n        return Promise.resolve();\n    },\n    // Messages\n    async getMessages (connId) {\n        const db = getMockDB();\n        return Promise.resolve(db.messages.filter((m)=>m.connection_id === connId).sort((a, b)=>new Date(a.created_at).getTime() - new Date(b.created_at).getTime()));\n    },\n    async sendMessage (connId, senderId, text) {\n        const db = getMockDB();\n        const msg = {\n            id: crypto.randomUUID(),\n            connection_id: connId,\n            sender_id: senderId,\n            text,\n            created_at: new Date().toISOString()\n        };\n        db.messages.push(msg);\n        updateMockDB(db);\n        return Promise.resolve(msg);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2RhdGFTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBRWM7QUFFbkUsaUJBQWlCO0FBQ2pCLE1BQU1FLGVBQWVDLDBDQUFvQyxJQUFJLENBQXlCO0FBQ3RGLE1BQU1HLGVBQWVILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0cseUJBQXlCLElBQUk7QUFFdkQsTUFBTUMsV0FBV1IsbUVBQVlBLENBQUNFLGNBQWNJLGNBQWM7QUFFakUsOERBQThEO0FBQzlELE1BQU1HLGNBQWM7QUFFcEIsa0RBQWtEO0FBQ2xELE1BQU1DLFlBQVk7SUFDaEJDLE9BQU87UUFDTDtZQUFFQyxJQUFJO1lBQU1DLE9BQU87WUFBbUJDLE1BQU07WUFBYUMsWUFBWTtRQUFpRDtRQUN0SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBb0JDLE1BQU07WUFBWUMsWUFBWTtRQUFtRDtRQUN2SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBb0JDLE1BQU07WUFBWUMsWUFBWTtRQUFtRDtRQUN2SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBa0JDLE1BQU07WUFBZUMsWUFBWTtRQUFvRDtLQUMxSDtJQUNEQyxVQUFVO1FBQ1I7WUFDRUosSUFBSTtZQUFZSyxTQUFTO1lBQU1DLGNBQWM7WUFBZ0JDLFVBQVU7WUFBMkJDLEtBQUs7WUFBeURDLFlBQVk7WUFDNUtDLFlBQVk7Z0JBQ1I7b0JBQUVDLFNBQVM7b0JBQWdCQyxNQUFNO29CQUFpQkMsTUFBTTtvQkFBUUMsSUFBSTtnQkFBVTtnQkFDOUU7b0JBQUVILFNBQVM7b0JBQWFDLE1BQU07b0JBQW9CQyxNQUFNO29CQUFRQyxJQUFJO2dCQUFPO2FBQzlFO1lBQ0RDLFdBQVc7Z0JBQUM7b0JBQUVDLGFBQWE7b0JBQVdDLFFBQVE7b0JBQWNDLE1BQU07Z0JBQU87YUFBRTtZQUMzRUMsUUFBUTtnQkFBQztnQkFBUztnQkFBUztnQkFBa0I7YUFBYztZQUMzREMsY0FBYztZQUNkQyxj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QUFXSDtZQUNYQztZQUNBYixZQUFZLElBQUkzRSxPQUFPQyxXQUFXO1FBQ3RDO1FBQ0FpQyxHQUFHL0IsUUFBUSxDQUFDeUMsSUFBSSxDQUFDNkM7UUFDakI3RSxhQUFhc0I7UUFDYixPQUFPYSxRQUFRQyxPQUFPLENBQUN5QztJQUN6QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvZGF0YVNlcnZpY2UudHM/MzQ5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgTmVhcmJ5VXNlciwgQ29ubmVjdGlvbiwgTWVzc2FnZSwgVXNlciwgUHJvZmlsZSwgTG9jYXRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXREaXN0YW5jZUZyb21MYXRMb25Jbk1ldGVycyB9IGZyb20gJy4uL3V0aWxzL2hhdmVyc2luZSc7XG5cbi8vIC0tLSBDT05GSUcgLS0tXG5jb25zdCBTVVBBQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgJ2h0dHBzOi8veHl6LnN1cGFiYXNlLmNvJztcbmNvbnN0IFNVUEFCQVNFX0tFWSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgfHwgJ21vY2sta2V5JztcblxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFNVUEFCQVNFX1VSTCwgU1VQQUJBU0VfS0VZKTtcblxuLy8gLS0tIE1PQ0sgREFUQSBTVE9SRSAoTG9jYWxTdG9yYWdlIHBlcnNpc3RlbmNlIGZvciBkZW1vKSAtLS1cbmNvbnN0IFNUT1JBR0VfS0VZID0gJ2xpbmttZV9tb2NrX2RiX3Y1JztcblxuLy8gUHJlLXNlZWRlZCByaWNoIGRhdGEgZm9yIHRoZSBcIkRlbW8gVXNlclwiICgnbWUnKVxuY29uc3QgU0VFREVEX0RCID0ge1xuICB1c2VyczogW1xuICAgIHsgaWQ6ICdtZScsIGVtYWlsOiAnZGVtb0BsaW5rbWUuY29tJywgbmFtZTogJ0RlbW8gVXNlcicsIGF2YXRhcl91cmw6ICdodHRwczovL2FwaS5kaWNlYmVhci5jb20vNy54L21pY2FoL3N2Zz9zZWVkPW1lJyB9LFxuICAgIHsgaWQ6ICcxJywgZW1haWw6ICdhbWFuQGV4YW1wbGUuY29tJywgbmFtZTogJ0FtYW4gUm95JywgYXZhdGFyX3VybDogJ2h0dHBzOi8vYXBpLmRpY2ViZWFyLmNvbS83LngvbWljYWgvc3ZnP3NlZWQ9YW1hbicgfSxcbiAgICB7IGlkOiAnMicsIGVtYWlsOiAnbWF5YUBleGFtcGxlLmNvbScsIG5hbWU6ICdNYXlhIFNlbicsIGF2YXRhcl91cmw6ICdodHRwczovL2FwaS5kaWNlYmVhci5jb20vNy54L21pY2FoL3N2Zz9zZWVkPW1heWEnIH0sXG4gICAgeyBpZDogJzMnLCBlbWFpbDogJ2VsYXJhQHRlY2guY29tJywgbmFtZTogJ0VsYXJhIFZhbmNlJywgYXZhdGFyX3VybDogJ2h0dHBzOi8vYXBpLmRpY2ViZWFyLmNvbS83LngvbWljYWgvc3ZnP3NlZWQ9ZWxhcmEnIH0sXG4gIF0gYXMgVXNlcltdLFxuICBwcm9maWxlczogW1xuICAgIHsgXG4gICAgICBpZDogJ3BfbWVfcHJvJywgdXNlcl9pZDogJ21lJywgcHJvZmlsZV90eXBlOiAncHJvZmVzc2lvbmFsJywgaGVhZGxpbmU6ICdTZW5pb3IgUHJvZHVjdCBEZXNpZ25lcicsIGJpbzogJ09ic2Vzc2VkIHdpdGggU3dpc3MgZGVzaWduIGFuZCBmdW5jdGlvbmFsIG1pbmltYWxpc20uJywgdmlzaWJpbGl0eTogJ25lYXJieScsXG4gICAgICBleHBlcmllbmNlOiBbXG4gICAgICAgICAgeyBjb21wYW55OiAnU3R1ZGlvIEFscGhhJywgcm9sZTogJ0xlYWQgRGVzaWduZXInLCBmcm9tOiAnMjAyMScsIHRvOiAnUHJlc2VudCcgfSxcbiAgICAgICAgICB7IGNvbXBhbnk6ICdGcmVlbGFuY2UnLCByb2xlOiAnVUkvVVggQ29uc3VsdGFudCcsIGZyb206ICcyMDE5JywgdG86ICcyMDIxJyB9XG4gICAgICBdLCBcbiAgICAgIGVkdWNhdGlvbjogW3sgaW5zdGl0dXRpb246ICdQYXJzb25zJywgZGVncmVlOiAnQkZBIERlc2lnbicsIHllYXI6ICcyMDE4JyB9XSwgXG4gICAgICBza2lsbHM6IFsnRmlnbWEnLCAnUmVhY3QnLCAnRGVzaWduIFN5c3RlbXMnLCAnUHJvdG90eXBpbmcnXSwgXG4gICAgICBvcGVuX3RvX3dvcms6IHRydWUsXG4gICAgICBsaW5rZWRpbl91cmw6ICdsaW5rZWRpbi5jb20vaW4vZGVtbycsXG4gICAgICBob2JiaWVzOiBbXSwgcHJvbXB0czogW11cbiAgICB9LFxuICAgIHsgXG4gICAgICBpZDogJ3BfbWVfcGVycycsIHVzZXJfaWQ6ICdtZScsIHByb2ZpbGVfdHlwZTogJ3BlcnNvbmFsJywgaGVhZGxpbmU6ICdDb2ZmZWUgJiBNYXJhdGhvbnMnLCBiaW86ICdUcmFpbmluZyBmb3IgdGhlIE5ZQyBtYXJhdGhvbi4gQWx3YXlzIGxvb2tpbmcgZm9yIG5ldyBlc3ByZXNzbyBzcG90cy4nLCB2aXNpYmlsaXR5OiAnbmVhcmJ5JyxcbiAgICAgIGV4cGVyaWVuY2U6IFtdLCBlZHVjYXRpb246IFtdLCBcbiAgICAgIGhvYmJpZXM6IFsnUnVubmluZycsICdFc3ByZXNzbycsICdBcmNoaXRlY3R1cmUnLCAnVmlueWwnXSwgXG4gICAgICBwcm9tcHRzOiBbXG4gICAgICAgICAge3F1ZXN0aW9uOiAnQSBwZXJmZWN0IFN1bmRheSBpcy4uLicsIGFuc3dlcjogJ1J1bm5pbmcgMTBrIHRoZW4gZmluZGluZyB0aGUgcGVyZmVjdCBiYWdlbC4nfSxcbiAgICAgICAgICB7cXVlc3Rpb246ICdJIGdlZWsgb3V0IG9uLi4uJywgYW5zd2VyOiAnTWlkLWNlbnR1cnkgZnVybml0dXJlLid9XG4gICAgICBdLCBcbiAgICAgIHJlbGF0aW9uc2hpcF9nb2FsOiAnZnJpZW5kcycsXG4gICAgICBpbnN0YWdyYW1faGFuZGxlOiAnQGRlbW9fcnVucydcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAncDEnLCB1c2VyX2lkOiAnMScsIHByb2ZpbGVfdHlwZTogJ3Byb2Zlc3Npb25hbCcsIGhlYWRsaW5lOiAnUHJvZHVjdCBNYW5hZ2VyIEAgQmVhY29uIExhYnMnLCBiaW86ICdCdWlsZGluZyB0b29scyBmb3IgdGhlIGZ1dHVyZSBvZiB3b3JrLicsIHZpc2liaWxpdHk6ICduZWFyYnknLFxuICAgICAgZXhwZXJpZW5jZTogW3sgY29tcGFueTogJ0JlYWNvbiBMYWJzJywgcm9sZTogJ1BNJywgZnJvbTogJzIwMjEnLCB0bzogJ1ByZXNlbnQnIH1dLCBlZHVjYXRpb246IFtdLCBza2lsbHM6IFsnUHJvZHVjdCBTdHJhdGVneScsICdBZ2lsZScsICdKaXJhJ10sIGxpbmtlZGluX3VybDogJ2xpbmtlZGluLmNvbS9hbWFuJywgb3Blbl90b193b3JrOiBmYWxzZSxcbiAgICAgIGhvYmJpZXM6IFtdLCBwcm9tcHRzOiBbXVxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICdwMicsIHVzZXJfaWQ6ICcyJywgcHJvZmlsZV90eXBlOiAncGVyc29uYWwnLCBoZWFkbGluZTogJ0hpa2luZyAmIFBob3RvZ3JhcGh5JywgYmlvOiAnTG9va2luZyBmb3IgaGlraW5nIGJ1ZGRpZXMgZm9yIHVwc3RhdGUgdHJhaWxzLicsIHZpc2liaWxpdHk6ICduZWFyYnknLFxuICAgICAgZXhwZXJpZW5jZTogW10sIGVkdWNhdGlvbjogW10sIGluc3RhZ3JhbV9oYW5kbGU6ICdAbWF5YV9oaWtlcycsIGhvYmJpZXM6IFsnSGlraW5nJywgJ1Bob3RvZ3JhcGh5JywgJ05hdHVyZSddLCByZWxhdGlvbnNoaXBfZ29hbDogJ25ldHdvcmtpbmcnLFxuICAgICAgcHJvbXB0czogW3txdWVzdGlvbjogJ015IHNlY3JldCB0YWxlbnQgaXMuLi4nLCBhbnN3ZXI6ICdGaW5kaW5nIHRoZSBiZXN0IHN1bnNldCBzcG90cy4nfV1cbiAgICB9LFxuICAgICB7XG4gICAgICBpZDogJ3AzJywgdXNlcl9pZDogJzMnLCBwcm9maWxlX3R5cGU6ICdwcm9mZXNzaW9uYWwnLCBoZWFkbGluZTogJ1VYIFJlc2VhcmNoZXInLCBiaW86ICdTcGVjaWFsaXppbmcgaW4gcHJveGltaXR5IGludGVyYWN0aW9ucy4nLCB2aXNpYmlsaXR5OiAnbmVhcmJ5JyxcbiAgICAgIGV4cGVyaWVuY2U6IFt7IGNvbXBhbnk6ICdHb29nbGUnLCByb2xlOiAnUmVzZWFyY2hlcicsIGZyb206ICcyMDE5JywgdG86ICcyMDIzJyB9XSwgZWR1Y2F0aW9uOiBbXSwgc2tpbGxzOiBbJ0ZpZ21hJywgJ1VzZXIgVGVzdGluZyddLCBvcGVuX3RvX3dvcms6IHRydWUsXG4gICAgICBob2JiaWVzOiBbXSwgcHJvbXB0czogW11cbiAgICB9XG4gIF0gYXMgUHJvZmlsZVtdLFxuICBsb2NhdGlvbnM6IFtcbiAgICB7IGlkOiAnbDEnLCB1c2VyX2lkOiAnMScsIGxhdGl0dWRlOiA0MC43MTYwLCBsb25naXR1ZGU6IC03NC4wMDkwLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSxcbiAgICB7IGlkOiAnbDInLCB1c2VyX2lkOiAnMicsIGxhdGl0dWRlOiA0MC43MTEwLCBsb25naXR1ZGU6IC03NC4wMDIwLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSxcbiAgICB7IGlkOiAnbDMnLCB1c2VyX2lkOiAnMycsIGxhdGl0dWRlOiA0MC43MTQwLCBsb25naXR1ZGU6IC03NC4wMDYwLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSxcbiAgXSBhcyBMb2NhdGlvbltdLFxuICBjb25uZWN0aW9uczogW10gYXMgQ29ubmVjdGlvbltdLFxuICBtZXNzYWdlczogW10gYXMgTWVzc2FnZVtdLFxufTtcblxuY29uc3QgZ2V0TW9ja0RCID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBTRUVERURfREI7XG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgaWYgKCFzdG9yZWQpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoU0VFREVEX0RCKSk7XG4gICAgcmV0dXJuIFNFRURFRF9EQjtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWQpO1xufTtcblxuY29uc3QgdXBkYXRlTW9ja0RCID0gKG5ld0RhdGE6IGFueSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkobmV3RGF0YSkpO1xufTtcblxuLy8gLS0tIFNFUlZJQ0UgTUVUSE9EUyAtLS1cblxuZXhwb3J0IGNvbnN0IGRhdGFTZXJ2aWNlID0ge1xuICAvLyBGZXRjaCB1c2VycyBuZWFyYnkgZnJvbSBTdXBhYmFzZSBBUElcbiAgYXN5bmMgZmV0Y2hOZWFyYnkobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyLCByYWRpdXM6IG51bWJlciwgdXNlcklkPzogc3RyaW5nKTogUHJvbWlzZTxOZWFyYnlVc2VyW10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGZldGNoIGZyb20gU3VwYWJhc2UgQVBJIGZpcnN0XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgbGF0OiBsYXQudG9TdHJpbmcoKSxcbiAgICAgICAgbG5nOiBsbmcudG9TdHJpbmcoKSxcbiAgICAgICAgcmFkaXVzOiByYWRpdXMudG9TdHJpbmcoKSxcbiAgICAgIH0pO1xuICAgICAgaWYgKHVzZXJJZCkge1xuICAgICAgICBwYXJhbXMuYXBwZW5kKCd1c2VySWQnLCB1c2VySWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2ZldGNoLW5lYXJieT8ke3BhcmFtcy50b1N0cmluZygpfWApO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGEgfHwgW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBBUEkgZmFpbHMsIGZhbGwgYmFjayB0byBtb2NrIGRhdGEgZm9yIGRlbW9cbiAgICAgICAgY29uc29sZS53YXJuKCdBUEkgZmV0Y2ggZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gbW9jayBkYXRhJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoTmVhcmJ5TW9jayhsYXQsIGxuZywgcmFkaXVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbmVhcmJ5IHVzZXJzOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGwgYmFjayB0byBtb2NrIGRhdGEgZm9yIGRlbW9cbiAgICAgIHJldHVybiB0aGlzLmZldGNoTmVhcmJ5TW9jayhsYXQsIGxuZywgcmFkaXVzKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gRmFsbGJhY2sgbW9jayBpbXBsZW1lbnRhdGlvblxuICBhc3luYyBmZXRjaE5lYXJieU1vY2sobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyLCByYWRpdXM6IG51bWJlcik6IFByb21pc2U8TmVhcmJ5VXNlcltdPiB7XG4gICAgY29uc3QgZGIgPSBnZXRNb2NrREIoKTtcbiAgICBjb25zdCBuZWFyYnk6IE5lYXJieVVzZXJbXSA9IFtdO1xuICAgIFxuICAgIGRiLmxvY2F0aW9ucy5mb3JFYWNoKChsb2M6IExvY2F0aW9uKSA9PiB7XG4gICAgICAvLyBVc2UgSGF2ZXJzaW5lIHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHRoZSBQQVNTRUQgbGF0L2xuZyAoVXNlcidzIGxvY2F0aW9uKVxuICAgICAgY29uc3QgZGlzdCA9IGdldERpc3RhbmNlRnJvbUxhdExvbkluTWV0ZXJzKGxhdCwgbG5nLCBsb2MubGF0aXR1ZGUsIGxvYy5sb25naXR1ZGUpO1xuICAgICAgaWYgKGRpc3QgPD0gcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBkYi51c2Vycy5maW5kKCh1OiBVc2VyKSA9PiB1LmlkID09PSBsb2MudXNlcl9pZCk7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBkYi5wcm9maWxlcy5maW5kKChwOiBQcm9maWxlKSA9PiBwLnVzZXJfaWQgPT09IGxvYy51c2VyX2lkICYmIHAudmlzaWJpbGl0eSAhPT0gJ3ByaXZhdGUnKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh1c2VyICYmIHByb2ZpbGUpIHtcbiAgICAgICAgICBuZWFyYnkucHVzaCh7IC4uLnVzZXIsIHByb2ZpbGUsIGxvY2F0aW9uOiBsb2MsIGRpc3RhbmNlOiBkaXN0IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU2ltdWxhdGUgbmV0d29yayBkZWxheVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShuZWFyYnkpLCA2MDApKTsgXG4gIH0sXG5cbiAgLy8gR2V0IG15IHByb2ZpbGVcbiAgYXN5bmMgZ2V0TXlQcm9maWxlKHVzZXJJZDogc3RyaW5nLCB0eXBlOiAncHJvZmVzc2lvbmFsJyB8ICdwZXJzb25hbCcpOiBQcm9taXNlPFByb2ZpbGUgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IHRvIGZldGNoIGZyb20gU3VwYWJhc2UgQVBJIGZpcnN0XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2dldC1wcm9maWxlP3VzZXJJZD0ke3VzZXJJZH0mcHJvZmlsZVR5cGU9JHt0eXBlfWApO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgbm90IGZvdW5kLCBjcmVhdGUgZGVmYXVsdCBwcm9maWxlIGluIFN1cGFiYXNlXG4gICAgICBjb25zdCBuZXdQcm9maWxlOiBQcm9maWxlID0ge1xuICAgICAgICBpZDogYHBfJHt1c2VySWR9XyR7dHlwZX1gLFxuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIHByb2ZpbGVfdHlwZTogdHlwZSxcbiAgICAgICAgaGVhZGxpbmU6IHR5cGUgPT09ICdwcm9mZXNzaW9uYWwnID8gJ05ldyBQcm9mZXNzaW9uYWwnIDogJ05ldyBVc2VyJyxcbiAgICAgICAgYmlvOiAnJyxcbiAgICAgICAgdmlzaWJpbGl0eTogJ25lYXJieScsXG4gICAgICAgIGV4cGVyaWVuY2U6IFtdLCBlZHVjYXRpb246IFtdLCBza2lsbHM6IFtdLCBob2JiaWVzOiBbXSwgcHJvbXB0czogW10sIG9wZW5fdG9fd29yazogZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gU3VwYWJhc2VcbiAgICAgIGF3YWl0IGZldGNoKCcvYXBpL3VwZGF0ZS1wcm9maWxlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5ld1Byb2ZpbGUpLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXdQcm9maWxlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9maWxlOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgY29uc3QgZGIgPSBnZXRNb2NrREIoKTtcbiAgICAgIGNvbnN0IHAgPSBkYi5wcm9maWxlcy5maW5kKChwOiBQcm9maWxlKSA9PiBwLnVzZXJfaWQgPT09IHVzZXJJZCAmJiBwLnByb2ZpbGVfdHlwZSA9PT0gdHlwZSk7XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgY29uc3QgbmV3UHJvZmlsZTogUHJvZmlsZSA9IHtcbiAgICAgICAgICBpZDogYHBfJHt1c2VySWR9XyR7dHlwZX1gLFxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBwcm9maWxlX3R5cGU6IHR5cGUsXG4gICAgICAgICAgaGVhZGxpbmU6IHR5cGUgPT09ICdwcm9mZXNzaW9uYWwnID8gJ05ldyBQcm9mZXNzaW9uYWwnIDogJ05ldyBVc2VyJyxcbiAgICAgICAgICBiaW86ICcnLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICduZWFyYnknLFxuICAgICAgICAgIGV4cGVyaWVuY2U6IFtdLCBlZHVjYXRpb246IFtdLCBza2lsbHM6IFtdLCBob2JiaWVzOiBbXSwgcHJvbXB0czogW10sIG9wZW5fdG9fd29yazogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgZGIucHJvZmlsZXMucHVzaChuZXdQcm9maWxlKTtcbiAgICAgICAgdXBkYXRlTW9ja0RCKGRiKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb2ZpbGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gVXBkYXRlIHByb2ZpbGVcbiAgYXN5bmMgdXBkYXRlUHJvZmlsZShwcm9maWxlOiBQcm9maWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNhdmUgdG8gU3VwYWJhc2UgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3VwZGF0ZS1wcm9maWxlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2ZpbGUpLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlIGluIFN1cGFiYXNlJyk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgICAgICBjb25zdCBpZHggPSBkYi5wcm9maWxlcy5maW5kSW5kZXgoKHA6IFByb2ZpbGUpID0+IHAuaWQgPT09IHByb2ZpbGUuaWQpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIGRiLnByb2ZpbGVzW2lkeF0gPSBwcm9maWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRiLnByb2ZpbGVzLnB1c2gocHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTW9ja0RCKGRiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcHJvZmlsZTonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgICBjb25zdCBpZHggPSBkYi5wcm9maWxlcy5maW5kSW5kZXgoKHA6IFByb2ZpbGUpID0+IHAuaWQgPT09IHByb2ZpbGUuaWQpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgZGIucHJvZmlsZXNbaWR4XSA9IHByb2ZpbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYi5wcm9maWxlcy5wdXNoKHByb2ZpbGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlTW9ja0RCKGRiKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQ29ubmVjdGlvbnNcbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbnModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPENvbm5lY3Rpb25bXT4ge1xuICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBkYi5jb25uZWN0aW9ucy5maWx0ZXIoKGM6IENvbm5lY3Rpb24pID0+IGMuZnJvbV91c2VyID09PSB1c2VySWQgfHwgYy50b191c2VyID09PSB1c2VySWQpO1xuICAgIFxuICAgIC8vIEh5ZHJhdGUgd2l0aCBwZWVyIGluZm9cbiAgICBjb25zdCBoeWRyYXRlZCA9IGNvbm5lY3Rpb25zLm1hcCgoYzogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgcGVlcklkID0gYy5mcm9tX3VzZXIgPT09IHVzZXJJZCA/IGMudG9fdXNlciA6IGMuZnJvbV91c2VyO1xuICAgICAgY29uc3QgcGVlciA9IGRiLnVzZXJzLmZpbmQoKHU6IFVzZXIpID0+IHUuaWQgPT09IHBlZXJJZCkgfHwgeyBpZDogcGVlcklkLCBuYW1lOiAnVW5rbm93bicsIGVtYWlsOiAnJyB9O1xuICAgICAgY29uc3QgcGVlclByb2ZpbGUgPSBkYi5wcm9maWxlcy5maW5kKChwOiBQcm9maWxlKSA9PiBwLnVzZXJfaWQgPT09IHBlZXJJZCAmJiBwLnByb2ZpbGVfdHlwZSA9PT0gYy5wcm9maWxlX3R5cGUpO1xuICAgICAgcmV0dXJuIHsgLi4uYywgcGVlciwgcGVlcl9wcm9maWxlOiBwZWVyUHJvZmlsZSB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaHlkcmF0ZWQpO1xuICB9LFxuXG4gIGFzeW5jIHNlbmRDb25uZWN0aW9uUmVxdWVzdChjb25uOiBQYXJ0aWFsPENvbm5lY3Rpb24+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNhdmUgdG8gU3VwYWJhc2UgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NlbmQtY29ubmVjdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uY29ubixcbiAgICAgICAgICBpZDogY29ubi5pZCB8fCBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBjb25uZWN0aW9uIHRvIFN1cGFiYXNlJyk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgICAgICBjb25zdCBuZXdDb25uID0ge1xuICAgICAgICAgIC4uLmNvbm4sXG4gICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBkYi5jb25uZWN0aW9ucy5wdXNoKG5ld0Nvbm4pO1xuICAgICAgICB1cGRhdGVNb2NrREIoZGIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIGNvbm5lY3Rpb24gcmVxdWVzdDonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgICBjb25zdCBuZXdDb25uID0ge1xuICAgICAgICAuLi5jb25uLFxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgZGIuY29ubmVjdGlvbnMucHVzaChuZXdDb25uKTtcbiAgICAgIHVwZGF0ZU1vY2tEQihkYik7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMoY29ubklkOiBzdHJpbmcsIHN0YXR1czogJ2FjY2VwdGVkJyB8ICdyZWplY3RlZCcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgIGNvbnN0IGlkeCA9IGRiLmNvbm5lY3Rpb25zLmZpbmRJbmRleCgoYzogQ29ubmVjdGlvbikgPT4gYy5pZCA9PT0gY29ubklkKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBkYi5jb25uZWN0aW9uc1tpZHhdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdXBkYXRlTW9ja0RCKGRiKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9LFxuXG4gIC8vIE1lc3NhZ2VzXG4gIGFzeW5jIGdldE1lc3NhZ2VzKGNvbm5JZDogc3RyaW5nKTogUHJvbWlzZTxNZXNzYWdlW10+IHtcbiAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGIubWVzc2FnZXMuZmlsdGVyKChtOiBNZXNzYWdlKSA9PiBtLmNvbm5lY3Rpb25faWQgPT09IGNvbm5JZCkuc29ydCgoYTpNZXNzYWdlLCBiOk1lc3NhZ2UpID0+IG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5jcmVhdGVkX2F0KS5nZXRUaW1lKCkpKTtcbiAgfSxcblxuICBhc3luYyBzZW5kTWVzc2FnZShjb25uSWQ6IHN0cmluZywgc2VuZGVySWQ6IHN0cmluZywgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgY29uc3QgZGIgPSBnZXRNb2NrREIoKTtcbiAgICBjb25zdCBtc2c6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBjb25uZWN0aW9uX2lkOiBjb25uSWQsXG4gICAgICAgIHNlbmRlcl9pZDogc2VuZGVySWQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgZGIubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIHVwZGF0ZU1vY2tEQihkYik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICB9XG59OyJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJnZXREaXN0YW5jZUZyb21MYXRMb25Jbk1ldGVycyIsIlNVUEFCQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJTVVBBQkFTRV9LRVkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwic3VwYWJhc2UiLCJTVE9SQUdFX0tFWSIsIlNFRURFRF9EQiIsInVzZXJzIiwiaWQiLCJlbWFpbCIsIm5hbWUiLCJhdmF0YXJfdXJsIiwicHJvZmlsZXMiLCJ1c2VyX2lkIiwicHJvZmlsZV90eXBlIiwiaGVhZGxpbmUiLCJiaW8iLCJ2aXNpYmlsaXR5IiwiZXhwZXJpZW5jZSIsImNvbXBhbnkiLCJyb2xlIiwiZnJvbSIsInRvIiwiZWR1Y2F0aW9uIiwiaW5zdGl0dXRpb24iLCJkZWdyZWUiLCJ5ZWFyIiwic2tpbGxzIiwib3Blbl90b193b3JrIiwibGlua2VkaW5fdXJsIiwiaG9iYmllcyIsInByb21wdHMiLCJxdWVzdGlvbiIsImFuc3dlciIsInJlbGF0aW9uc2hpcF9nb2FsIiwiaW5zdGFncmFtX2hhbmRsZSIsImxvY2F0aW9ucyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbm5lY3Rpb25zIiwibWVzc2FnZXMiLCJnZXRNb2NrREIiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsInVwZGF0ZU1vY2tEQiIsIm5ld0RhdGEiLCJkYXRhU2VydmljZSIsImZldGNoTmVhcmJ5IiwibGF0IiwibG5nIiwicmFkaXVzIiwidXNlcklkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJhcHBlbmQiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJyZXN1bHQiLCJqc29uIiwiZGF0YSIsImNvbnNvbGUiLCJ3YXJuIiwiZmV0Y2hOZWFyYnlNb2NrIiwiZXJyb3IiLCJkYiIsIm5lYXJieSIsImZvckVhY2giLCJsb2MiLCJkaXN0IiwidXNlciIsImZpbmQiLCJ1IiwicHJvZmlsZSIsInAiLCJwdXNoIiwibG9jYXRpb24iLCJkaXN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldE15UHJvZmlsZSIsInR5cGUiLCJuZXdQcm9maWxlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ1cGRhdGVQcm9maWxlIiwiaWR4IiwiZmluZEluZGV4IiwiZ2V0Q29ubmVjdGlvbnMiLCJmaWx0ZXIiLCJjIiwiZnJvbV91c2VyIiwidG9fdXNlciIsImh5ZHJhdGVkIiwibWFwIiwicGVlcklkIiwicGVlciIsInBlZXJQcm9maWxlIiwicGVlcl9wcm9maWxlIiwic2VuZENvbm5lY3Rpb25SZXF1ZXN0IiwiY29ubiIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJzdGF0dXMiLCJjcmVhdGVkX2F0IiwibmV3Q29ubiIsInVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMiLCJjb25uSWQiLCJnZXRNZXNzYWdlcyIsIm0iLCJjb25uZWN0aW9uX2lkIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsInNlbmRNZXNzYWdlIiwic2VuZGVySWQiLCJ0ZXh0IiwibXNnIiwic2VuZGVyX2lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/dataService.ts\n"));

/***/ })

});