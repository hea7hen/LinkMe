"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/dataService.ts":
/*!*********************************!*\
  !*** ./services/dataService.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataService: () => (/* binding */ dataService),\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _utils_haversine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/haversine */ \"(app-pages-browser)/./utils/haversine.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n// --- CONFIG ---\nconst SUPABASE_URL = \"https://rhgbghiznkqrvdbqufmq.supabase.co\" || 0;\nconst SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || 'mock-key';\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(SUPABASE_URL, SUPABASE_KEY);\n// --- MOCK DATA STORE (LocalStorage persistence for demo) ---\nconst STORAGE_KEY = 'linkme_mock_db_v5';\n// Pre-seeded rich data for the \"Demo User\" ('me')\nconst SEEDED_DB = {\n    users: [\n        {\n            id: 'me',\n            email: 'demo@linkme.com',\n            name: 'Demo User',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=me'\n        },\n        {\n            id: '1',\n            email: 'aman@example.com',\n            name: 'Aman Roy',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=aman'\n        },\n        {\n            id: '2',\n            email: 'maya@example.com',\n            name: 'Maya Sen',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=maya'\n        },\n        {\n            id: '3',\n            email: 'elara@tech.com',\n            name: 'Elara Vance',\n            avatar_url: 'https://api.dicebear.com/7.x/micah/svg?seed=elara'\n        }\n    ],\n    profiles: [\n        {\n            id: 'p_me_pro',\n            user_id: 'me',\n            profile_type: 'professional',\n            headline: 'Senior Product Designer',\n            bio: 'Obsessed with Swiss design and functional minimalism.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Studio Alpha',\n                    role: 'Lead Designer',\n                    from: '2021',\n                    to: 'Present'\n                },\n                {\n                    company: 'Freelance',\n                    role: 'UI/UX Consultant',\n                    from: '2019',\n                    to: '2021'\n                }\n            ],\n            education: [\n                {\n                    institution: 'Parsons',\n                    degree: 'BFA Design',\n                    year: '2018'\n                }\n            ],\n            skills: [\n                'Figma',\n                'React',\n                'Design Systems',\n                'Prototyping'\n            ],\n            open_to_work: true,\n            linkedin_url: 'linkedin.com/in/demo',\n            hobbies: [],\n            prompts: []\n        },\n        {\n            id: 'p_me_pers',\n            user_id: 'me',\n            profile_type: 'personal',\n            headline: 'Coffee & Marathons',\n            bio: 'Training for the NYC marathon. Always looking for new espresso spots.',\n            visibility: 'nearby',\n            experience: [],\n            education: [],\n            hobbies: [\n                'Running',\n                'Espresso',\n                'Architecture',\n                'Vinyl'\n            ],\n            prompts: [\n                {\n                    question: 'A perfect Sunday is...',\n                    answer: 'Running 10k then finding the perfect bagel.'\n                },\n                {\n                    question: 'I geek out on...',\n                    answer: 'Mid-century furniture.'\n                }\n            ],\n            relationship_goal: 'friends',\n            instagram_handle: '@demo_runs'\n        },\n        {\n            id: 'p1',\n            user_id: '1',\n            profile_type: 'professional',\n            headline: 'Product Manager @ Beacon Labs',\n            bio: 'Building tools for the future of work.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Beacon Labs',\n                    role: 'PM',\n                    from: '2021',\n                    to: 'Present'\n                }\n            ],\n            education: [],\n            skills: [\n                'Product Strategy',\n                'Agile',\n                'Jira'\n            ],\n            linkedin_url: 'linkedin.com/aman',\n            open_to_work: false,\n            hobbies: [],\n            prompts: []\n        },\n        {\n            id: 'p2',\n            user_id: '2',\n            profile_type: 'personal',\n            headline: 'Hiking & Photography',\n            bio: 'Looking for hiking buddies for upstate trails.',\n            visibility: 'nearby',\n            experience: [],\n            education: [],\n            instagram_handle: '@maya_hikes',\n            hobbies: [\n                'Hiking',\n                'Photography',\n                'Nature'\n            ],\n            relationship_goal: 'networking',\n            prompts: [\n                {\n                    question: 'My secret talent is...',\n                    answer: 'Finding the best sunset spots.'\n                }\n            ]\n        },\n        {\n            id: 'p3',\n            user_id: '3',\n            profile_type: 'professional',\n            headline: 'UX Researcher',\n            bio: 'Specializing in proximity interactions.',\n            visibility: 'nearby',\n            experience: [\n                {\n                    company: 'Google',\n                    role: 'Researcher',\n                    from: '2019',\n                    to: '2023'\n                }\n            ],\n            education: [],\n            skills: [\n                'Figma',\n                'User Testing'\n            ],\n            open_to_work: true,\n            hobbies: [],\n            prompts: []\n        }\n    ],\n    locations: [\n        {\n            id: 'l1',\n            user_id: '1',\n            latitude: 40.7160,\n            longitude: -74.0090,\n            updated_at: new Date().toISOString()\n        },\n        {\n            id: 'l2',\n            user_id: '2',\n            latitude: 40.7110,\n            longitude: -74.0020,\n            updated_at: new Date().toISOString()\n        },\n        {\n            id: 'l3',\n            user_id: '3',\n            latitude: 40.7140,\n            longitude: -74.0060,\n            updated_at: new Date().toISOString()\n        }\n    ],\n    connections: [],\n    messages: []\n};\nconst getMockDB = ()=>{\n    if (false) {}\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (!stored) {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(SEEDED_DB));\n        return SEEDED_DB;\n    }\n    return JSON.parse(stored);\n};\nconst updateMockDB = (newData)=>{\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(newData));\n};\n// --- SERVICE METHODS ---\nconst dataService = {\n    // Fetch users nearby from Supabase API\n    async fetchNearby (lat, lng, radius, userId) {\n        try {\n            // Try to fetch from Supabase API first\n            const params = new URLSearchParams({\n                lat: lat.toString(),\n                lng: lng.toString(),\n                radius: radius.toString()\n            });\n            if (userId) {\n                params.append('userId', userId);\n            }\n            const response = await fetch(\"/api/fetch-nearby?\".concat(params.toString()));\n            if (response.ok) {\n                const result = await response.json();\n                return result.data || [];\n            } else {\n                // If API fails, fall back to mock data for demo\n                console.warn('API fetch failed, falling back to mock data');\n                return this.fetchNearbyMock(lat, lng, radius);\n            }\n        } catch (error) {\n            console.error('Error fetching nearby users:', error);\n            // Fall back to mock data for demo\n            return this.fetchNearbyMock(lat, lng, radius);\n        }\n    },\n    // Fallback mock implementation\n    async fetchNearbyMock (lat, lng, radius) {\n        const db = getMockDB();\n        const nearby = [];\n        db.locations.forEach((loc)=>{\n            // Use Haversine to calculate distance from the PASSED lat/lng (User's location)\n            const dist = (0,_utils_haversine__WEBPACK_IMPORTED_MODULE_0__.getDistanceFromLatLonInMeters)(lat, lng, loc.latitude, loc.longitude);\n            if (dist <= radius) {\n                const user = db.users.find((u)=>u.id === loc.user_id);\n                const profile = db.profiles.find((p)=>p.user_id === loc.user_id && p.visibility !== 'private');\n                if (user && profile) {\n                    nearby.push({\n                        ...user,\n                        profile,\n                        location: loc,\n                        distance: dist\n                    });\n                }\n            }\n        });\n        // Simulate network delay\n        return new Promise((resolve)=>setTimeout(()=>resolve(nearby), 600));\n    },\n    // Get my profile\n    async getMyProfile (userId, type) {\n        try {\n            // Try to fetch from Supabase API first\n            const response = await fetch(\"/api/get-profile?userId=\".concat(userId, \"&profileType=\").concat(type));\n            if (response.ok) {\n                const result = await response.json();\n                if (result.data) {\n                    return result.data;\n                }\n            }\n            // If not found, create default profile in Supabase\n            const newProfile = {\n                id: \"p_\".concat(userId, \"_\").concat(type),\n                user_id: userId,\n                profile_type: type,\n                headline: type === 'professional' ? 'New Professional' : 'New User',\n                bio: '',\n                visibility: 'nearby',\n                experience: [],\n                education: [],\n                skills: [],\n                hobbies: [],\n                prompts: [],\n                open_to_work: false\n            };\n            // Save to Supabase\n            await fetch('/api/update-profile', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(newProfile)\n            });\n            return newProfile;\n        } catch (error) {\n            console.error('Error fetching profile:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const p = db.profiles.find((p)=>p.user_id === userId && p.profile_type === type);\n            if (!p) {\n                const newProfile = {\n                    id: \"p_\".concat(userId, \"_\").concat(type),\n                    user_id: userId,\n                    profile_type: type,\n                    headline: type === 'professional' ? 'New Professional' : 'New User',\n                    bio: '',\n                    visibility: 'nearby',\n                    experience: [],\n                    education: [],\n                    skills: [],\n                    hobbies: [],\n                    prompts: [],\n                    open_to_work: false\n                };\n                db.profiles.push(newProfile);\n                updateMockDB(db);\n                return newProfile;\n            }\n            return p;\n        }\n    },\n    // Update profile\n    async updateProfile (profile) {\n        try {\n            // Save to Supabase API\n            const response = await fetch('/api/update-profile', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(profile)\n            });\n            if (!response.ok) {\n                console.error('Failed to update profile in Supabase');\n                // Fallback to mock data\n                const db = getMockDB();\n                const idx = db.profiles.findIndex((p)=>p.id === profile.id);\n                if (idx !== -1) {\n                    db.profiles[idx] = profile;\n                } else {\n                    db.profiles.push(profile);\n                }\n                updateMockDB(db);\n            }\n        } catch (error) {\n            console.error('Error updating profile:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const idx = db.profiles.findIndex((p)=>p.id === profile.id);\n            if (idx !== -1) {\n                db.profiles[idx] = profile;\n            } else {\n                db.profiles.push(profile);\n            }\n            updateMockDB(db);\n        }\n    },\n    // Connections\n    async getConnections (userId) {\n        try {\n            // Fetch from Supabase API\n            const response = await fetch(\"/api/get-connections?userId=\".concat(userId));\n            if (response.ok) {\n                const result = await response.json();\n                return result.data || [];\n            }\n            // Fallback to mock data\n            const db = getMockDB();\n            const connections = db.connections.filter((c)=>c.from_user === userId || c.to_user === userId);\n            // Hydrate with peer info\n            const hydrated = connections.map((c)=>{\n                const peerId = c.from_user === userId ? c.to_user : c.from_user;\n                const peer = db.users.find((u)=>u.id === peerId) || {\n                    id: peerId,\n                    name: 'Unknown',\n                    email: ''\n                };\n                const peerProfile = db.profiles.find((p)=>p.user_id === peerId && p.profile_type === c.profile_type);\n                return {\n                    ...c,\n                    peer,\n                    peer_profile: peerProfile\n                };\n            });\n            return hydrated;\n        } catch (error) {\n            console.error('Error fetching connections:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const connections = db.connections.filter((c)=>c.from_user === userId || c.to_user === userId);\n            const hydrated = connections.map((c)=>{\n                const peerId = c.from_user === userId ? c.to_user : c.from_user;\n                const peer = db.users.find((u)=>u.id === peerId) || {\n                    id: peerId,\n                    name: 'Unknown',\n                    email: ''\n                };\n                const peerProfile = db.profiles.find((p)=>p.user_id === peerId && p.profile_type === c.profile_type);\n                return {\n                    ...c,\n                    peer,\n                    peer_profile: peerProfile\n                };\n            });\n            return hydrated;\n        }\n    },\n    async sendConnectionRequest (conn) {\n        try {\n            // Save to Supabase API\n            const response = await fetch('/api/send-connection', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    ...conn,\n                    id: conn.id || crypto.randomUUID(),\n                    status: 'pending',\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                })\n            });\n            if (!response.ok) {\n                console.error('Failed to save connection to Supabase');\n                // Fallback to mock data\n                const db = getMockDB();\n                const newConn = {\n                    ...conn,\n                    id: crypto.randomUUID(),\n                    status: 'pending',\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                db.connections.push(newConn);\n                updateMockDB(db);\n            }\n        } catch (error) {\n            console.error('Error sending connection request:', error);\n            // Fallback to mock data\n            const db = getMockDB();\n            const newConn = {\n                ...conn,\n                id: crypto.randomUUID(),\n                status: 'pending',\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            db.connections.push(newConn);\n            updateMockDB(db);\n        }\n    },\n    async updateConnectionStatus (connId, status) {\n        const db = getMockDB();\n        const idx = db.connections.findIndex((c)=>c.id === connId);\n        if (idx !== -1) {\n            db.connections[idx].status = status;\n            updateMockDB(db);\n        }\n        return Promise.resolve();\n    },\n    // Messages\n    async getMessages (connId) {\n        const db = getMockDB();\n        return Promise.resolve(db.messages.filter((m)=>m.connection_id === connId).sort((a, b)=>new Date(a.created_at).getTime() - new Date(b.created_at).getTime()));\n    },\n    async sendMessage (connId, senderId, text) {\n        const db = getMockDB();\n        const msg = {\n            id: crypto.randomUUID(),\n            connection_id: connId,\n            sender_id: senderId,\n            text,\n            created_at: new Date().toISOString()\n        };\n        db.messages.push(msg);\n        updateMockDB(db);\n        return Promise.resolve(msg);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2RhdGFTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBRWM7QUFFbkUsaUJBQWlCO0FBQ2pCLE1BQU1FLGVBQWVDLDBDQUFvQyxJQUFJLENBQXlCO0FBQ3RGLE1BQU1HLGVBQWVILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0cseUJBQXlCLElBQUk7QUFFdkQsTUFBTUMsV0FBV1IsbUVBQVlBLENBQUNFLGNBQWNJLGNBQWM7QUFFakUsOERBQThEO0FBQzlELE1BQU1HLGNBQWM7QUFFcEIsa0RBQWtEO0FBQ2xELE1BQU1DLFlBQVk7SUFDaEJDLE9BQU87UUFDTDtZQUFFQyxJQUFJO1lBQU1DLE9BQU87WUFBbUJDLE1BQU07WUFBYUMsWUFBWTtRQUFpRDtRQUN0SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBb0JDLE1BQU07WUFBWUMsWUFBWTtRQUFtRDtRQUN2SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBb0JDLE1BQU07WUFBWUMsWUFBWTtRQUFtRDtRQUN2SDtZQUFFSCxJQUFJO1lBQUtDLE9BQU87WUFBa0JDLE1BQU07WUFBZUMsWUFBWTtRQUFvRDtLQUMxSDtJQUNEQyxVQUFVO1FBQ1I7WUFDRUosSUFBSTtZQUFZSyxTQUFTO1lBQU1DLGNBQWM7WUFBZ0JDLFVBQVU7WUFBMkJDLEtBQUs7WUFBeURDLFlBQVk7WUFDNUtDLFlBQVk7Z0JBQ1I7b0JBQUVDLFNBQVM7b0JBQWdCQyxNQUFNO29CQUFpQkMsTUFBTTtvQkFBUUMsSUFBSTtnQkFBVTtnQkFDOUU7b0JBQUVILFNBQVM7b0JBQWFDLE1BQU07b0JBQW9CQyxNQUFNO29CQUFRQyxJQUFJO2dCQUFPO2FBQzlFO1lBQ0RDLFdBQVc7Z0JBQUM7b0JBQUVDLGFBQWE7b0JBQVdDLFFBQVE7b0JBQWNDLE1BQU07Z0JBQU87YUFBRTtZQUMzRUMsUUFBUTtnQkFBQztnQkFBUztnQkFBUztnQkFBa0I7YUFBYztZQUMzREMsY0FBYztZQUNkQyxj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QU9hLFFBQVFDLE9BQU8sQ0FBQ3lDO0lBQ3pCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zZXJ2aWNlcy9kYXRhU2VydmljZS50cz8zNDkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBOZWFyYnlVc2VyLCBDb25uZWN0aW9uLCBNZXNzYWdlLCBVc2VyLCBQcm9maWxlLCBMb2NhdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldERpc3RhbmNlRnJvbUxhdExvbkluTWV0ZXJzIH0gZnJvbSAnLi4vdXRpbHMvaGF2ZXJzaW5lJztcblxuLy8gLS0tIENPTkZJRyAtLS1cbmNvbnN0IFNVUEFCQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCB8fCAnaHR0cHM6Ly94eXouc3VwYWJhc2UuY28nO1xuY29uc3QgU1VQQUJBU0VfS0VZID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSB8fCAnbW9jay1rZXknO1xuXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoU1VQQUJBU0VfVVJMLCBTVVBBQkFTRV9LRVkpO1xuXG4vLyAtLS0gTU9DSyBEQVRBIFNUT1JFIChMb2NhbFN0b3JhZ2UgcGVyc2lzdGVuY2UgZm9yIGRlbW8pIC0tLVxuY29uc3QgU1RPUkFHRV9LRVkgPSAnbGlua21lX21vY2tfZGJfdjUnO1xuXG4vLyBQcmUtc2VlZGVkIHJpY2ggZGF0YSBmb3IgdGhlIFwiRGVtbyBVc2VyXCIgKCdtZScpXG5jb25zdCBTRUVERURfREIgPSB7XG4gIHVzZXJzOiBbXG4gICAgeyBpZDogJ21lJywgZW1haWw6ICdkZW1vQGxpbmttZS5jb20nLCBuYW1lOiAnRGVtbyBVc2VyJywgYXZhdGFyX3VybDogJ2h0dHBzOi8vYXBpLmRpY2ViZWFyLmNvbS83LngvbWljYWgvc3ZnP3NlZWQ9bWUnIH0sXG4gICAgeyBpZDogJzEnLCBlbWFpbDogJ2FtYW5AZXhhbXBsZS5jb20nLCBuYW1lOiAnQW1hbiBSb3knLCBhdmF0YXJfdXJsOiAnaHR0cHM6Ly9hcGkuZGljZWJlYXIuY29tLzcueC9taWNhaC9zdmc/c2VlZD1hbWFuJyB9LFxuICAgIHsgaWQ6ICcyJywgZW1haWw6ICdtYXlhQGV4YW1wbGUuY29tJywgbmFtZTogJ01heWEgU2VuJywgYXZhdGFyX3VybDogJ2h0dHBzOi8vYXBpLmRpY2ViZWFyLmNvbS83LngvbWljYWgvc3ZnP3NlZWQ9bWF5YScgfSxcbiAgICB7IGlkOiAnMycsIGVtYWlsOiAnZWxhcmFAdGVjaC5jb20nLCBuYW1lOiAnRWxhcmEgVmFuY2UnLCBhdmF0YXJfdXJsOiAnaHR0cHM6Ly9hcGkuZGljZWJlYXIuY29tLzcueC9taWNhaC9zdmc/c2VlZD1lbGFyYScgfSxcbiAgXSBhcyBVc2VyW10sXG4gIHByb2ZpbGVzOiBbXG4gICAgeyBcbiAgICAgIGlkOiAncF9tZV9wcm8nLCB1c2VyX2lkOiAnbWUnLCBwcm9maWxlX3R5cGU6ICdwcm9mZXNzaW9uYWwnLCBoZWFkbGluZTogJ1NlbmlvciBQcm9kdWN0IERlc2lnbmVyJywgYmlvOiAnT2JzZXNzZWQgd2l0aCBTd2lzcyBkZXNpZ24gYW5kIGZ1bmN0aW9uYWwgbWluaW1hbGlzbS4nLCB2aXNpYmlsaXR5OiAnbmVhcmJ5JyxcbiAgICAgIGV4cGVyaWVuY2U6IFtcbiAgICAgICAgICB7IGNvbXBhbnk6ICdTdHVkaW8gQWxwaGEnLCByb2xlOiAnTGVhZCBEZXNpZ25lcicsIGZyb206ICcyMDIxJywgdG86ICdQcmVzZW50JyB9LFxuICAgICAgICAgIHsgY29tcGFueTogJ0ZyZWVsYW5jZScsIHJvbGU6ICdVSS9VWCBDb25zdWx0YW50JywgZnJvbTogJzIwMTknLCB0bzogJzIwMjEnIH1cbiAgICAgIF0sIFxuICAgICAgZWR1Y2F0aW9uOiBbeyBpbnN0aXR1dGlvbjogJ1BhcnNvbnMnLCBkZWdyZWU6ICdCRkEgRGVzaWduJywgeWVhcjogJzIwMTgnIH1dLCBcbiAgICAgIHNraWxsczogWydGaWdtYScsICdSZWFjdCcsICdEZXNpZ24gU3lzdGVtcycsICdQcm90b3R5cGluZyddLCBcbiAgICAgIG9wZW5fdG9fd29yazogdHJ1ZSxcbiAgICAgIGxpbmtlZGluX3VybDogJ2xpbmtlZGluLmNvbS9pbi9kZW1vJyxcbiAgICAgIGhvYmJpZXM6IFtdLCBwcm9tcHRzOiBbXVxuICAgIH0sXG4gICAgeyBcbiAgICAgIGlkOiAncF9tZV9wZXJzJywgdXNlcl9pZDogJ21lJywgcHJvZmlsZV90eXBlOiAncGVyc29uYWwnLCBoZWFkbGluZTogJ0NvZmZlZSAmIE1hcmF0aG9ucycsIGJpbzogJ1RyYWluaW5nIGZvciB0aGUgTllDIG1hcmF0aG9uLiBBbHdheXMgbG9va2luZyBmb3IgbmV3IGVzcHJlc3NvIHNwb3RzLicsIHZpc2liaWxpdHk6ICduZWFyYnknLFxuICAgICAgZXhwZXJpZW5jZTogW10sIGVkdWNhdGlvbjogW10sIFxuICAgICAgaG9iYmllczogWydSdW5uaW5nJywgJ0VzcHJlc3NvJywgJ0FyY2hpdGVjdHVyZScsICdWaW55bCddLCBcbiAgICAgIHByb21wdHM6IFtcbiAgICAgICAgICB7cXVlc3Rpb246ICdBIHBlcmZlY3QgU3VuZGF5IGlzLi4uJywgYW5zd2VyOiAnUnVubmluZyAxMGsgdGhlbiBmaW5kaW5nIHRoZSBwZXJmZWN0IGJhZ2VsLid9LFxuICAgICAgICAgIHtxdWVzdGlvbjogJ0kgZ2VlayBvdXQgb24uLi4nLCBhbnN3ZXI6ICdNaWQtY2VudHVyeSBmdXJuaXR1cmUuJ31cbiAgICAgIF0sIFxuICAgICAgcmVsYXRpb25zaGlwX2dvYWw6ICdmcmllbmRzJyxcbiAgICAgIGluc3RhZ3JhbV9oYW5kbGU6ICdAZGVtb19ydW5zJ1xuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICdwMScsIHVzZXJfaWQ6ICcxJywgcHJvZmlsZV90eXBlOiAncHJvZmVzc2lvbmFsJywgaGVhZGxpbmU6ICdQcm9kdWN0IE1hbmFnZXIgQCBCZWFjb24gTGFicycsIGJpbzogJ0J1aWxkaW5nIHRvb2xzIGZvciB0aGUgZnV0dXJlIG9mIHdvcmsuJywgdmlzaWJpbGl0eTogJ25lYXJieScsXG4gICAgICBleHBlcmllbmNlOiBbeyBjb21wYW55OiAnQmVhY29uIExhYnMnLCByb2xlOiAnUE0nLCBmcm9tOiAnMjAyMScsIHRvOiAnUHJlc2VudCcgfV0sIGVkdWNhdGlvbjogW10sIHNraWxsczogWydQcm9kdWN0IFN0cmF0ZWd5JywgJ0FnaWxlJywgJ0ppcmEnXSwgbGlua2VkaW5fdXJsOiAnbGlua2VkaW4uY29tL2FtYW4nLCBvcGVuX3RvX3dvcms6IGZhbHNlLFxuICAgICAgaG9iYmllczogW10sIHByb21wdHM6IFtdXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3AyJywgdXNlcl9pZDogJzInLCBwcm9maWxlX3R5cGU6ICdwZXJzb25hbCcsIGhlYWRsaW5lOiAnSGlraW5nICYgUGhvdG9ncmFwaHknLCBiaW86ICdMb29raW5nIGZvciBoaWtpbmcgYnVkZGllcyBmb3IgdXBzdGF0ZSB0cmFpbHMuJywgdmlzaWJpbGl0eTogJ25lYXJieScsXG4gICAgICBleHBlcmllbmNlOiBbXSwgZWR1Y2F0aW9uOiBbXSwgaW5zdGFncmFtX2hhbmRsZTogJ0BtYXlhX2hpa2VzJywgaG9iYmllczogWydIaWtpbmcnLCAnUGhvdG9ncmFwaHknLCAnTmF0dXJlJ10sIHJlbGF0aW9uc2hpcF9nb2FsOiAnbmV0d29ya2luZycsXG4gICAgICBwcm9tcHRzOiBbe3F1ZXN0aW9uOiAnTXkgc2VjcmV0IHRhbGVudCBpcy4uLicsIGFuc3dlcjogJ0ZpbmRpbmcgdGhlIGJlc3Qgc3Vuc2V0IHNwb3RzLid9XVxuICAgIH0sXG4gICAgIHtcbiAgICAgIGlkOiAncDMnLCB1c2VyX2lkOiAnMycsIHByb2ZpbGVfdHlwZTogJ3Byb2Zlc3Npb25hbCcsIGhlYWRsaW5lOiAnVVggUmVzZWFyY2hlcicsIGJpbzogJ1NwZWNpYWxpemluZyBpbiBwcm94aW1pdHkgaW50ZXJhY3Rpb25zLicsIHZpc2liaWxpdHk6ICduZWFyYnknLFxuICAgICAgZXhwZXJpZW5jZTogW3sgY29tcGFueTogJ0dvb2dsZScsIHJvbGU6ICdSZXNlYXJjaGVyJywgZnJvbTogJzIwMTknLCB0bzogJzIwMjMnIH1dLCBlZHVjYXRpb246IFtdLCBza2lsbHM6IFsnRmlnbWEnLCAnVXNlciBUZXN0aW5nJ10sIG9wZW5fdG9fd29yazogdHJ1ZSxcbiAgICAgIGhvYmJpZXM6IFtdLCBwcm9tcHRzOiBbXVxuICAgIH1cbiAgXSBhcyBQcm9maWxlW10sXG4gIGxvY2F0aW9uczogW1xuICAgIHsgaWQ6ICdsMScsIHVzZXJfaWQ6ICcxJywgbGF0aXR1ZGU6IDQwLjcxNjAsIGxvbmdpdHVkZTogLTc0LjAwOTAsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9LFxuICAgIHsgaWQ6ICdsMicsIHVzZXJfaWQ6ICcyJywgbGF0aXR1ZGU6IDQwLjcxMTAsIGxvbmdpdHVkZTogLTc0LjAwMjAsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9LFxuICAgIHsgaWQ6ICdsMycsIHVzZXJfaWQ6ICczJywgbGF0aXR1ZGU6IDQwLjcxNDAsIGxvbmdpdHVkZTogLTc0LjAwNjAsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9LFxuICBdIGFzIExvY2F0aW9uW10sXG4gIGNvbm5lY3Rpb25zOiBbXSBhcyBDb25uZWN0aW9uW10sXG4gIG1lc3NhZ2VzOiBbXSBhcyBNZXNzYWdlW10sXG59O1xuXG5jb25zdCBnZXRNb2NrREIgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFNFRURFRF9EQjtcbiAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpO1xuICBpZiAoIXN0b3JlZCkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShTRUVERURfREIpKTtcbiAgICByZXR1cm4gU0VFREVEX0RCO1xuICB9XG4gIHJldHVybiBKU09OLnBhcnNlKHN0b3JlZCk7XG59O1xuXG5jb25zdCB1cGRhdGVNb2NrREIgPSAobmV3RGF0YTogYW55KSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShuZXdEYXRhKSk7XG59O1xuXG4vLyAtLS0gU0VSVklDRSBNRVRIT0RTIC0tLVxuXG5leHBvcnQgY29uc3QgZGF0YVNlcnZpY2UgPSB7XG4gIC8vIEZldGNoIHVzZXJzIG5lYXJieSBmcm9tIFN1cGFiYXNlIEFQSVxuICBhc3luYyBmZXRjaE5lYXJieShsYXQ6IG51bWJlciwgbG5nOiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPE5lYXJieVVzZXJbXT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZmV0Y2ggZnJvbSBTdXBhYmFzZSBBUEkgZmlyc3RcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBsYXQ6IGxhdC50b1N0cmluZygpLFxuICAgICAgICBsbmc6IGxuZy50b1N0cmluZygpLFxuICAgICAgICByYWRpdXM6IHJhZGl1cy50b1N0cmluZygpLFxuICAgICAgfSk7XG4gICAgICBpZiAodXNlcklkKSB7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoJ3VzZXJJZCcsIHVzZXJJZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZmV0Y2gtbmVhcmJ5PyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YSB8fCBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIEFQSSBmYWlscywgZmFsbCBiYWNrIHRvIG1vY2sgZGF0YSBmb3IgZGVtb1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FQSSBmZXRjaCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBtb2NrIGRhdGEnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hOZWFyYnlNb2NrKGxhdCwgbG5nLCByYWRpdXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBuZWFyYnkgdXNlcnM6JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIG1vY2sgZGF0YSBmb3IgZGVtb1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hOZWFyYnlNb2NrKGxhdCwgbG5nLCByYWRpdXMpO1xuICAgIH1cbiAgfSxcblxuICAvLyBGYWxsYmFjayBtb2NrIGltcGxlbWVudGF0aW9uXG4gIGFzeW5jIGZldGNoTmVhcmJ5TW9jayhsYXQ6IG51bWJlciwgbG5nOiBudW1iZXIsIHJhZGl1czogbnVtYmVyKTogUHJvbWlzZTxOZWFyYnlVc2VyW10+IHtcbiAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgIGNvbnN0IG5lYXJieTogTmVhcmJ5VXNlcltdID0gW107XG4gICAgXG4gICAgZGIubG9jYXRpb25zLmZvckVhY2goKGxvYzogTG9jYXRpb24pID0+IHtcbiAgICAgIC8vIFVzZSBIYXZlcnNpbmUgdG8gY2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gdGhlIFBBU1NFRCBsYXQvbG5nIChVc2VyJ3MgbG9jYXRpb24pXG4gICAgICBjb25zdCBkaXN0ID0gZ2V0RGlzdGFuY2VGcm9tTGF0TG9uSW5NZXRlcnMobGF0LCBsbmcsIGxvYy5sYXRpdHVkZSwgbG9jLmxvbmdpdHVkZSk7XG4gICAgICBpZiAoZGlzdCA8PSByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgdXNlciA9IGRiLnVzZXJzLmZpbmQoKHU6IFVzZXIpID0+IHUuaWQgPT09IGxvYy51c2VyX2lkKTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IGRiLnByb2ZpbGVzLmZpbmQoKHA6IFByb2ZpbGUpID0+IHAudXNlcl9pZCA9PT0gbG9jLnVzZXJfaWQgJiYgcC52aXNpYmlsaXR5ICE9PSAncHJpdmF0ZScpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVzZXIgJiYgcHJvZmlsZSkge1xuICAgICAgICAgIG5lYXJieS5wdXNoKHsgLi4udXNlciwgcHJvZmlsZSwgbG9jYXRpb246IGxvYywgZGlzdGFuY2U6IGRpc3QgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBTaW11bGF0ZSBuZXR3b3JrIGRlbGF5XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKG5lYXJieSksIDYwMCkpOyBcbiAgfSxcblxuICAvLyBHZXQgbXkgcHJvZmlsZVxuICBhc3luYyBnZXRNeVByb2ZpbGUodXNlcklkOiBzdHJpbmcsIHR5cGU6ICdwcm9mZXNzaW9uYWwnIHwgJ3BlcnNvbmFsJyk6IFByb21pc2U8UHJvZmlsZSB8IHVuZGVmaW5lZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZmV0Y2ggZnJvbSBTdXBhYmFzZSBBUEkgZmlyc3RcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZ2V0LXByb2ZpbGU/dXNlcklkPSR7dXNlcklkfSZwcm9maWxlVHlwZT0ke3R5cGV9YCk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBub3QgZm91bmQsIGNyZWF0ZSBkZWZhdWx0IHByb2ZpbGUgaW4gU3VwYWJhc2VcbiAgICAgIGNvbnN0IG5ld1Byb2ZpbGU6IFByb2ZpbGUgPSB7XG4gICAgICAgIGlkOiBgcF8ke3VzZXJJZH1fJHt0eXBlfWAsXG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgcHJvZmlsZV90eXBlOiB0eXBlLFxuICAgICAgICBoZWFkbGluZTogdHlwZSA9PT0gJ3Byb2Zlc3Npb25hbCcgPyAnTmV3IFByb2Zlc3Npb25hbCcgOiAnTmV3IFVzZXInLFxuICAgICAgICBiaW86ICcnLFxuICAgICAgICB2aXNpYmlsaXR5OiAnbmVhcmJ5JyxcbiAgICAgICAgZXhwZXJpZW5jZTogW10sIGVkdWNhdGlvbjogW10sIHNraWxsczogW10sIGhvYmJpZXM6IFtdLCBwcm9tcHRzOiBbXSwgb3Blbl90b193b3JrOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBTdXBhYmFzZVxuICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvdXBkYXRlLXByb2ZpbGUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobmV3UHJvZmlsZSksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ld1Byb2ZpbGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2ZpbGU6JywgZXJyb3IpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gICAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgICAgY29uc3QgcCA9IGRiLnByb2ZpbGVzLmZpbmQoKHA6IFByb2ZpbGUpID0+IHAudXNlcl9pZCA9PT0gdXNlcklkICYmIHAucHJvZmlsZV90eXBlID09PSB0eXBlKTtcbiAgICAgIGlmICghcCkge1xuICAgICAgICBjb25zdCBuZXdQcm9maWxlOiBQcm9maWxlID0ge1xuICAgICAgICAgIGlkOiBgcF8ke3VzZXJJZH1fJHt0eXBlfWAsXG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIHByb2ZpbGVfdHlwZTogdHlwZSxcbiAgICAgICAgICBoZWFkbGluZTogdHlwZSA9PT0gJ3Byb2Zlc3Npb25hbCcgPyAnTmV3IFByb2Zlc3Npb25hbCcgOiAnTmV3IFVzZXInLFxuICAgICAgICAgIGJpbzogJycsXG4gICAgICAgICAgdmlzaWJpbGl0eTogJ25lYXJieScsXG4gICAgICAgICAgZXhwZXJpZW5jZTogW10sIGVkdWNhdGlvbjogW10sIHNraWxsczogW10sIGhvYmJpZXM6IFtdLCBwcm9tcHRzOiBbXSwgb3Blbl90b193b3JrOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBkYi5wcm9maWxlcy5wdXNoKG5ld1Byb2ZpbGUpO1xuICAgICAgICB1cGRhdGVNb2NrREIoZGIpO1xuICAgICAgICByZXR1cm4gbmV3UHJvZmlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgcHJvZmlsZVxuICBhc3luYyB1cGRhdGVQcm9maWxlKHByb2ZpbGU6IFByb2ZpbGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gU2F2ZSB0byBTdXBhYmFzZSBBUElcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvdXBkYXRlLXByb2ZpbGUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJvZmlsZSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUgaW4gU3VwYWJhc2UnKTtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gICAgICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IGRiLnByb2ZpbGVzLmZpbmRJbmRleCgocDogUHJvZmlsZSkgPT4gcC5pZCA9PT0gcHJvZmlsZS5pZCk7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgZGIucHJvZmlsZXNbaWR4XSA9IHByb2ZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGIucHJvZmlsZXMucHVzaChwcm9maWxlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVNb2NrREIoZGIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9maWxlOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgY29uc3QgZGIgPSBnZXRNb2NrREIoKTtcbiAgICAgIGNvbnN0IGlkeCA9IGRiLnByb2ZpbGVzLmZpbmRJbmRleCgocDogUHJvZmlsZSkgPT4gcC5pZCA9PT0gcHJvZmlsZS5pZCk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBkYi5wcm9maWxlc1tpZHhdID0gcHJvZmlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRiLnByb2ZpbGVzLnB1c2gocHJvZmlsZSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVNb2NrREIoZGIpO1xuICAgIH1cbiAgfSxcblxuICAvLyBDb25uZWN0aW9uc1xuICBhc3luYyBnZXRDb25uZWN0aW9ucyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Q29ubmVjdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGZyb20gU3VwYWJhc2UgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2dldC1jb25uZWN0aW9ucz91c2VySWQ9JHt1c2VySWR9YCk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YSB8fCBbXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gICAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBkYi5jb25uZWN0aW9ucy5maWx0ZXIoKGM6IENvbm5lY3Rpb24pID0+IGMuZnJvbV91c2VyID09PSB1c2VySWQgfHwgYy50b191c2VyID09PSB1c2VySWQpO1xuICAgICAgXG4gICAgICAvLyBIeWRyYXRlIHdpdGggcGVlciBpbmZvXG4gICAgICBjb25zdCBoeWRyYXRlZCA9IGNvbm5lY3Rpb25zLm1hcCgoYzogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBwZWVySWQgPSBjLmZyb21fdXNlciA9PT0gdXNlcklkID8gYy50b191c2VyIDogYy5mcm9tX3VzZXI7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBkYi51c2Vycy5maW5kKCh1OiBVc2VyKSA9PiB1LmlkID09PSBwZWVySWQpIHx8IHsgaWQ6IHBlZXJJZCwgbmFtZTogJ1Vua25vd24nLCBlbWFpbDogJycgfTtcbiAgICAgICAgY29uc3QgcGVlclByb2ZpbGUgPSBkYi5wcm9maWxlcy5maW5kKChwOiBQcm9maWxlKSA9PiBwLnVzZXJfaWQgPT09IHBlZXJJZCAmJiBwLnByb2ZpbGVfdHlwZSA9PT0gYy5wcm9maWxlX3R5cGUpO1xuICAgICAgICByZXR1cm4geyAuLi5jLCBwZWVyLCBwZWVyX3Byb2ZpbGU6IHBlZXJQcm9maWxlIH07XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGh5ZHJhdGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb25uZWN0aW9uczonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGRiLmNvbm5lY3Rpb25zLmZpbHRlcigoYzogQ29ubmVjdGlvbikgPT4gYy5mcm9tX3VzZXIgPT09IHVzZXJJZCB8fCBjLnRvX3VzZXIgPT09IHVzZXJJZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGh5ZHJhdGVkID0gY29ubmVjdGlvbnMubWFwKChjOiBDb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IGMuZnJvbV91c2VyID09PSB1c2VySWQgPyBjLnRvX3VzZXIgOiBjLmZyb21fdXNlcjtcbiAgICAgICAgY29uc3QgcGVlciA9IGRiLnVzZXJzLmZpbmQoKHU6IFVzZXIpID0+IHUuaWQgPT09IHBlZXJJZCkgfHwgeyBpZDogcGVlcklkLCBuYW1lOiAnVW5rbm93bicsIGVtYWlsOiAnJyB9O1xuICAgICAgICBjb25zdCBwZWVyUHJvZmlsZSA9IGRiLnByb2ZpbGVzLmZpbmQoKHA6IFByb2ZpbGUpID0+IHAudXNlcl9pZCA9PT0gcGVlcklkICYmIHAucHJvZmlsZV90eXBlID09PSBjLnByb2ZpbGVfdHlwZSk7XG4gICAgICAgIHJldHVybiB7IC4uLmMsIHBlZXIsIHBlZXJfcHJvZmlsZTogcGVlclByb2ZpbGUgfTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gaHlkcmF0ZWQ7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHNlbmRDb25uZWN0aW9uUmVxdWVzdChjb25uOiBQYXJ0aWFsPENvbm5lY3Rpb24+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNhdmUgdG8gU3VwYWJhc2UgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NlbmQtY29ubmVjdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uY29ubixcbiAgICAgICAgICBpZDogY29ubi5pZCB8fCBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBjb25uZWN0aW9uIHRvIFN1cGFiYXNlJyk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgICAgICBjb25zdCBuZXdDb25uID0ge1xuICAgICAgICAgIC4uLmNvbm4sXG4gICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBkYi5jb25uZWN0aW9ucy5wdXNoKG5ld0Nvbm4pO1xuICAgICAgICB1cGRhdGVNb2NrREIoZGIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIGNvbm5lY3Rpb24gcmVxdWVzdDonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IGRiID0gZ2V0TW9ja0RCKCk7XG4gICAgICBjb25zdCBuZXdDb25uID0ge1xuICAgICAgICAuLi5jb25uLFxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgZGIuY29ubmVjdGlvbnMucHVzaChuZXdDb25uKTtcbiAgICAgIHVwZGF0ZU1vY2tEQihkYik7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMoY29ubklkOiBzdHJpbmcsIHN0YXR1czogJ2FjY2VwdGVkJyB8ICdyZWplY3RlZCcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgIGNvbnN0IGlkeCA9IGRiLmNvbm5lY3Rpb25zLmZpbmRJbmRleCgoYzogQ29ubmVjdGlvbikgPT4gYy5pZCA9PT0gY29ubklkKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBkYi5jb25uZWN0aW9uc1tpZHhdLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdXBkYXRlTW9ja0RCKGRiKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9LFxuXG4gIC8vIE1lc3NhZ2VzXG4gIGFzeW5jIGdldE1lc3NhZ2VzKGNvbm5JZDogc3RyaW5nKTogUHJvbWlzZTxNZXNzYWdlW10+IHtcbiAgICBjb25zdCBkYiA9IGdldE1vY2tEQigpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGIubWVzc2FnZXMuZmlsdGVyKChtOiBNZXNzYWdlKSA9PiBtLmNvbm5lY3Rpb25faWQgPT09IGNvbm5JZCkuc29ydCgoYTpNZXNzYWdlLCBiOk1lc3NhZ2UpID0+IG5ldyBEYXRlKGEuY3JlYXRlZF9hdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5jcmVhdGVkX2F0KS5nZXRUaW1lKCkpKTtcbiAgfSxcblxuICBhc3luYyBzZW5kTWVzc2FnZShjb25uSWQ6IHN0cmluZywgc2VuZGVySWQ6IHN0cmluZywgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgY29uc3QgZGIgPSBnZXRNb2NrREIoKTtcbiAgICBjb25zdCBtc2c6IE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICBjb25uZWN0aW9uX2lkOiBjb25uSWQsXG4gICAgICAgIHNlbmRlcl9pZDogc2VuZGVySWQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgZGIubWVzc2FnZXMucHVzaChtc2cpO1xuICAgIHVwZGF0ZU1vY2tEQihkYik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICB9XG59OyJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJnZXREaXN0YW5jZUZyb21MYXRMb25Jbk1ldGVycyIsIlNVUEFCQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJTVVBBQkFTRV9LRVkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwic3VwYWJhc2UiLCJTVE9SQUdFX0tFWSIsIlNFRURFRF9EQiIsInVzZXJzIiwiaWQiLCJlbWFpbCIsIm5hbWUiLCJhdmF0YXJfdXJsIiwicHJvZmlsZXMiLCJ1c2VyX2lkIiwicHJvZmlsZV90eXBlIiwiaGVhZGxpbmUiLCJiaW8iLCJ2aXNpYmlsaXR5IiwiZXhwZXJpZW5jZSIsImNvbXBhbnkiLCJyb2xlIiwiZnJvbSIsInRvIiwiZWR1Y2F0aW9uIiwiaW5zdGl0dXRpb24iLCJkZWdyZWUiLCJ5ZWFyIiwic2tpbGxzIiwib3Blbl90b193b3JrIiwibGlua2VkaW5fdXJsIiwiaG9iYmllcyIsInByb21wdHMiLCJxdWVzdGlvbiIsImFuc3dlciIsInJlbGF0aW9uc2hpcF9nb2FsIiwiaW5zdGFncmFtX2hhbmRsZSIsImxvY2F0aW9ucyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbm5lY3Rpb25zIiwibWVzc2FnZXMiLCJnZXRNb2NrREIiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsInVwZGF0ZU1vY2tEQiIsIm5ld0RhdGEiLCJkYXRhU2VydmljZSIsImZldGNoTmVhcmJ5IiwibGF0IiwibG5nIiwicmFkaXVzIiwidXNlcklkIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJhcHBlbmQiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJyZXN1bHQiLCJqc29uIiwiZGF0YSIsImNvbnNvbGUiLCJ3YXJuIiwiZmV0Y2hOZWFyYnlNb2NrIiwiZXJyb3IiLCJkYiIsIm5lYXJieSIsImZvckVhY2giLCJsb2MiLCJkaXN0IiwidXNlciIsImZpbmQiLCJ1IiwicHJvZmlsZSIsInAiLCJwdXNoIiwibG9jYXRpb24iLCJkaXN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldE15UHJvZmlsZSIsInR5cGUiLCJuZXdQcm9maWxlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ1cGRhdGVQcm9maWxlIiwiaWR4IiwiZmluZEluZGV4IiwiZ2V0Q29ubmVjdGlvbnMiLCJmaWx0ZXIiLCJjIiwiZnJvbV91c2VyIiwidG9fdXNlciIsImh5ZHJhdGVkIiwibWFwIiwicGVlcklkIiwicGVlciIsInBlZXJQcm9maWxlIiwicGVlcl9wcm9maWxlIiwic2VuZENvbm5lY3Rpb25SZXF1ZXN0IiwiY29ubiIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJzdGF0dXMiLCJjcmVhdGVkX2F0IiwibmV3Q29ubiIsInVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMiLCJjb25uSWQiLCJnZXRNZXNzYWdlcyIsIm0iLCJjb25uZWN0aW9uX2lkIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsInNlbmRNZXNzYWdlIiwic2VuZGVySWQiLCJ0ZXh0IiwibXNnIiwic2VuZGVyX2lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/dataService.ts\n"));

/***/ })

});